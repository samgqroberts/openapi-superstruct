import { generate } from '.';

describe('generate', () => {
  describe('file input', () => {
    it('case: simple', async () => {
      const file = await generate({
        input: './src/sample-specs/simple.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_ModelOne = s.object({
  string_field_one: s.string(),
  string_field_two: s.optional(s.string()),
});

export const structs = {
  ModelOne: struct_ModelOne,
};

export type ModelOne = s.Infer<typeof structs['ModelOne']>;
`);
    });
    it('case: one-model-all-primitives', async () => {
      const file = await generate({
        input: './src/sample-specs/one-model-all-primitives.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_ModelOne = s.object({
  required_string: s.string(),
  required_nullable_string: s.nullable(s.string()),
  optional_string: s.optional(s.string()),
  optional_nullable_string: s.optional(s.nullable(s.string())),
  required_string_date: s.string(),
  required_nullable_string_date: s.nullable(s.string()),
  optional_string_date: s.optional(s.string()),
  optional_nullable_string_date: s.optional(s.nullable(s.string())),
  required_string_date-time: s.string(),
  required_nullable_string_date-time: s.nullable(s.string()),
  optional_string_date-time: s.optional(s.string()),
  optional_nullable_string_date-time: s.optional(s.nullable(s.string())),
  required_string_password: s.string(),
  required_nullable_string_password: s.nullable(s.string()),
  optional_string_password: s.optional(s.string()),
  optional_nullable_string_password: s.optional(s.nullable(s.string())),
  required_string_byte: s.string(),
  required_nullable_string_byte: s.nullable(s.string()),
  optional_string_byte: s.optional(s.string()),
  optional_nullable_string_byte: s.optional(s.nullable(s.string())),
  required_string_binary: s.string(),
  required_nullable_string_binary: s.nullable(s.string()),
  optional_string_binary: s.optional(s.string()),
  optional_nullable_string_binary: s.optional(s.nullable(s.string())),
  required_number: s.number(),
  required_nullable_number: s.nullable(s.number()),
  optional_number: s.optional(s.number()),
  optional_nullable_number: s.optional(s.nullable(s.number())),
  required_number_float: s.number(),
  required_nullable_number_float: s.nullable(s.number()),
  optional_number_float: s.optional(s.number()),
  optional_nullable_number_float: s.optional(s.nullable(s.number())),
  required_number_double: s.number(),
  required_nullable_number_double: s.nullable(s.number()),
  optional_number_double: s.optional(s.number()),
  optional_nullable_number_double: s.optional(s.nullable(s.number())),
  required_integer: s.integer(),
  required_nullable_integer: s.nullable(s.integer()),
  optional_integer: s.optional(s.integer()),
  optional_nullable_integer: s.optional(s.nullable(s.integer())),
  required_integer_int32: s.integer(),
  required_nullable_integer_int32: s.nullable(s.integer()),
  optional_integer_int32: s.optional(s.integer()),
  optional_nullable_integer_int32: s.optional(s.nullable(s.integer())),
  required_integer_int64: s.integer(),
  required_nullable_integer_int64: s.nullable(s.integer()),
  optional_integer_int64: s.optional(s.integer()),
  optional_nullable_integer_int64: s.optional(s.nullable(s.integer())),
  required_boolean: s.boolean(),
  required_nullable_boolean: s.nullable(s.boolean()),
  optional_boolean: s.optional(s.boolean()),
  optional_nullable_boolean: s.optional(s.nullable(s.boolean())),
});

export const structs = {
  ModelOne: struct_ModelOne,
};

export type ModelOne = s.Infer<typeof structs['ModelOne']>;
`);
    });
    it('case: one-model-complex-types', async () => {
      const file = await generate({
        input: './src/sample-specs/one-model-complex-types.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_ModelOne = s.object({
  required_array<string>: s.array(s.string()),
  required_nullable_array<string>: s.nullable(s.array(s.string())),
  optional_array<string>: s.optional(s.array(s.string())),
  optional_nullable_array<string>: s.optional(s.nullable(s.array(s.string()))),
  required_array<nullable_string>: s.array(s.nullable(s.string())),
  deeply_nested_array: s.optional(s.array(s.array(s.array(s.integer())))),
  required_object: s.object({
    nested_required_string: s.string(),
    nested_optional_nullable_integer: s.optional(s.nullable(s.integer())),
    nested_required_array<boolean>: s.array(s.boolean()),
    nested_required_object: s.object({
      doubly_nested_required_string: s.string(),
    }),
  }),
});

export const structs = {
  ModelOne: struct_ModelOne,
};

export type ModelOne = s.Infer<typeof structs['ModelOne']>;
`);
    });
    it('case: multiple-models-top-level-primitives', async () => {
      const file = await generate({
        input: './src/sample-specs/multiple-models-top-level-primitives.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_String = s.string();
const struct_Nullable_string_date = s.nullable(s.string());
const struct_String_date-time = s.string();
const struct_Nullable_string_password = s.nullable(s.string());
const struct_String_byte = s.string();
const struct_Nullable_string_binary = s.nullable(s.string());
const struct_Number = s.number();
const struct_Nullable_number_float = s.nullable(s.number());
const struct_Number_double = s.number();
const struct_Nullable_integer = s.nullable(s.integer());
const struct_Integer_int32 = s.integer();
const struct_Nullable_integer_int64 = s.nullable(s.integer());
const struct_Boolean = s.boolean();

export const structs = {
  String: struct_String,
  Nullable_string_date: struct_Nullable_string_date,
  String_date-time: struct_String_date-time,
  Nullable_string_password: struct_Nullable_string_password,
  String_byte: struct_String_byte,
  Nullable_string_binary: struct_Nullable_string_binary,
  Number: struct_Number,
  Nullable_number_float: struct_Nullable_number_float,
  Number_double: struct_Number_double,
  Nullable_integer: struct_Nullable_integer,
  Integer_int32: struct_Integer_int32,
  Nullable_integer_int64: struct_Nullable_integer_int64,
  Boolean: struct_Boolean,
};

export type String = s.Infer<typeof structs['String']>;
export type Nullable_string_date = s.Infer<typeof structs['Nullable_string_date']>;
export type String_date-time = s.Infer<typeof structs['String_date-time']>;
export type Nullable_string_password = s.Infer<typeof structs['Nullable_string_password']>;
export type String_byte = s.Infer<typeof structs['String_byte']>;
export type Nullable_string_binary = s.Infer<typeof structs['Nullable_string_binary']>;
export type Number = s.Infer<typeof structs['Number']>;
export type Nullable_number_float = s.Infer<typeof structs['Nullable_number_float']>;
export type Number_double = s.Infer<typeof structs['Number_double']>;
export type Nullable_integer = s.Infer<typeof structs['Nullable_integer']>;
export type Integer_int32 = s.Infer<typeof structs['Integer_int32']>;
export type Nullable_integer_int64 = s.Infer<typeof structs['Nullable_integer_int64']>;
export type Boolean = s.Infer<typeof structs['Boolean']>;
`);
    });
    it('case: references', async () => {
      const file = await generate({
        input: './src/sample-specs/references.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_BasicModel = s.object({
  some_model_one_field: s.string(),
});
const struct_IsReference = struct_BasicModel;
const struct_IsReferenceToReferer = struct_BasicModel;
const struct_HasReferences = s.object({
  reference_field: struct_BasicModel,
});
const struct_HasRecursiveReference = s.object({
  recursive_reference_field: s.optional(struct_HasRecursiveReference),
});

export const structs = {
  BasicModel: struct_BasicModel,
  IsReference: struct_IsReference,
  IsReferenceToReferer: struct_IsReferenceToReferer,
  HasReferences: struct_HasReferences,
  HasRecursiveReference: struct_HasRecursiveReference,
};

export type BasicModel = s.Infer<typeof structs['BasicModel']>;
export type IsReference = s.Infer<typeof structs['IsReference']>;
export type IsReferenceToReferer = s.Infer<typeof structs['IsReferenceToReferer']>;
export type HasReferences = s.Infer<typeof structs['HasReferences']>;
export type HasRecursiveReference = s.Infer<typeof structs['HasRecursiveReference']>;
`);
    });
    it('case: multiple-models-misc-cases', async () => {
      const file = await generate({
        input: './src/sample-specs/multiple-models-misc-cases.json'
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_Has_spaces_in_name = s.object({
  field with spaces: s.string(),
  just has default: s.literal("SOME VALUE"),
});

export const structs = {
  Has_spaces_in_name: struct_Has_spaces_in_name,
};

export type Has_spaces_in_name = s.Infer<typeof structs['Has_spaces_in_name']>;
`);
    });
  });
  describe('object input', () => {
    it('case: simple', async () => {
      const file = await generate({
        input: {
          components: {
            schemas: {
              ModelOne: {
                properties: {
                  string_field_one: {
                    type: 'string'
                  },
                  string_field_two: {
                    type: 'string'
                  }
                },
                required: ['string_field_one'],
                type: 'object'
              }
            }
          }
        }
      });
      expect(file).toEqual(`/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

const struct_ModelOne = s.object({
  string_field_one: s.string(),
  string_field_two: s.optional(s.string()),
});

export const structs = {
  ModelOne: struct_ModelOne,
};

export type ModelOne = s.Infer<typeof structs['ModelOne']>;
`);
    });
  });
});
