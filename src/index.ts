import { existsSync, writeFileSync } from 'fs';
import $RefParser from 'json-schema-ref-parser';
import { fileSync } from 'tmp';

export interface GenerateParams {
  input: string | object;
}

function variableName(name: string): string {
  return name.replace(/\s/g, '_');
}

export async function generate({ input }: GenerateParams): Promise<string> {
  const spec = await parseInputOrThrow(input);
  const schemas = spec?.components?.schemas || {};
  const components = Object.entries(schemas)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .map(([modelName, schema]: [string, any]) => {
      const varName = variableName(modelName);
      const declaration = `const struct_${varName} = ${deriveSType(
        1,
        modelName,
        null,
        schema,
        []
      )};`;
      const struct = `  ${varName}: struct_${varName},`;
      const type = `export type ${varName} = s.Infer<typeof structs['${varName}']>;`;
      return [declaration, struct, type];
    });
  const declarations = components.map((c) => c[0]).join('\n');
  const structs = components.map((c) => c[1]).join('\n');
  const types = components.map((c) => c[2]).join('\n');
  const file = `/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

${declarations}

export const structs = {
${structs}
};

${types}
`;
  return file;
}

function deriveSType(
  indentation: number,
  modelName: string,
  propertyName: string | null,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  type: any,
  required: string[]
): string {
  if (!type) {
    return 's.unknown()';
  }
  const base = type.type;
  const isNullable = !!type.nullable;
  const isOptional = propertyName !== null && !required.includes(propertyName);
  const baseSType = (() => {
    if (base === 'string') return 's.string()';
    if (base === 'number') return 's.number()';
    if (base === 'integer') return 's.integer()';
    if (base === 'boolean') return 's.boolean()';
    if (base === 'array') {
      const items = type.items;
      const nestedSType = deriveSType(indentation, modelName, null, items, []);
      return `s.array(${nestedSType})`;
    }
    if (base === 'object') {
      const indentationStr = Array(indentation).join('  ');
      const nestedIndentationStr = indentationStr + '  ';
      const propertiesStr = Object.entries(type.properties || {})
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        .map(([nestedPropertyName, nestedType]: [string, any]) => {
          const sType = deriveSType(
            indentation + 1,
            modelName,
            nestedPropertyName,
            nestedType,
            type.required || []
          );
          return `${nestedIndentationStr}${nestedPropertyName}: ${sType},`;
        })
        .join('\n');
      return `s.object({\n${propertiesStr}\n${indentationStr}})`;
    }
    if (typeof type.default === 'string') {
      return `s.literal("${type.default}")`;
    }
    if (typeof type.$ref === 'string') {
      const ref = type.$ref as string;
      if (ref.startsWith('#/components/schemas/')) {
        const refName = ref.substring('#/components/schemas/'.length);
        const structName = `struct_${variableName(refName)}`;
        return structName;
      }
    }
    console.warn('unknown', { propertyName, type, required });
    return 's.unknown()';
  })();
  const consideringNullable = isNullable
    ? `s.nullable(${baseSType})`
    : baseSType;
  const consideringOptional = isOptional
    ? `s.optional(${consideringNullable})`
    : consideringNullable;
  return consideringOptional;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function parseInputOrThrow(input: string | object): Promise<any> {
  if (typeof input === 'object') {
    return parseInputObjectOrThrow(input);
  }
  if (existsSync(input)) {
    return parseInputFileOrThrow(input);
  }
  return parseInputStringOrThrow(input);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseInputStringOrThrow = async (input: string): Promise<any> => {
  return parseInputObjectOrThrow(JSON.parse(input));
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function parseInputObjectOrThrow(obj: object): Promise<any> {
  const { fd, name: path } = fileSync();
  writeFileSync(fd, JSON.stringify(obj));
  const schema = await $RefParser.bundle(path, path, {});
  return schema;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseInputFileOrThrow = async (location: string): Promise<any> => {
  try {
    const schema = await $RefParser.bundle(location, location, {});
    return schema;
  } catch (e) {
    throw new Error(JSON.stringify(e));
  }
};
