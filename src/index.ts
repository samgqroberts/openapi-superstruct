import { existsSync, writeFileSync } from 'fs';
import $RefParser from 'json-schema-ref-parser';
import { fileSync } from 'tmp';

export interface GenerateParams {
  input: string | object;
}

export async function generate({ input }: GenerateParams): Promise<string> {
  const spec = await parseInputOrThrow(input);
  const schemas = spec?.components?.schemas || {};
  const objects = Object.entries(schemas)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .map(([modelName, schema]: [string, any]) => {
      return `export const s${modelName} = ${deriveSType(1, null, schema, [])}`;
    })
    .join('\n');
  const file = `/* autogenerated by openapi-superstruct */

import * as s from 'superstruct';

${objects}
`;
  return file;
}

function deriveSType(
  indentation: number,
  propertyName: string | null,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  type: any,
  required: string[]
): string {
  if (!type) {
    return 's.unknown()';
  }
  const base = type.type;
  const isNullable = !!type.nullable;
  const isOptional = propertyName !== null && !required.includes(propertyName);
  const baseSType = (() => {
    if (base === 'string') return 's.string()';
    if (base === 'number') return 's.number()';
    if (base === 'integer') return 's.integer()';
    if (base === 'boolean') return 's.boolean()';
    if (base === 'array') {
      const items = type.items;
      const nestedSType = deriveSType(indentation, null, items, []);
      return `s.array(${nestedSType})`;
    }
    if (base === 'object') {
      const indentationStr = Array(indentation).join('  ');
      const nestedIndentationStr = indentationStr + '  ';
      const propertiesStr = Object.entries(type.properties || {})
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        .map(([nestedPropertyName, nestedType]: [string, any]) => {
          const sType = deriveSType(
            indentation + 1,
            nestedPropertyName,
            nestedType,
            type.required || []
          );
          return `${nestedIndentationStr}${nestedPropertyName}: ${sType},`;
        })
        .join('\n');
      return `s.object({\n${propertiesStr}\n${indentationStr}})${
        indentation === 1 ? ';' : ''
      }`;
    }
    return 's.unknown()';
  })();
  const consideringNullable = isNullable
    ? `s.nullable(${baseSType})`
    : baseSType;
  const consideringOptional = isOptional
    ? `s.optional(${consideringNullable})`
    : consideringNullable;
  return consideringOptional;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function parseInputOrThrow(input: string | object): Promise<any> {
  if (typeof input === 'object') {
    return parseInputObjectOrThrow(input);
  }
  if (existsSync(input)) {
    return parseInputFileOrThrow(input);
  }
  return parseInputStringOrThrow(input);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseInputStringOrThrow = async (input: string): Promise<any> => {
  return parseInputObjectOrThrow(JSON.parse(input));
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function parseInputObjectOrThrow(obj: object): Promise<any> {
  const { fd, name: path } = fileSync();
  writeFileSync(fd, JSON.stringify(obj));
  const schema = await $RefParser.bundle(path, path, {});
  return schema;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseInputFileOrThrow = async (location: string): Promise<any> => {
  try {
    const schema = await $RefParser.bundle(location, location, {});
    return schema;
  } catch (e) {
    throw new Error(JSON.stringify(e));
  }
};
